

# Dokumentation


-----------------------------------------------------------------------------------------
## Metadata
-----------------------------------------------------------------------------------------

- Flybase




-----------------------------------------------------------------------------------------
## Project Description
-----------------------------------------------------------------------------------------

- `Drosophila` 

  Common Name and Family: The Drosophila family, commonly known as fruit flies, 
  belongs to the Drosophilidae family, which includes a wide variety 
  of small flies often used in genetic research.

  Chromosomal Information: Members of the Drosophila family typically have a diploid 
  chromosome number of 2n = 8, with their chromosomes arranged in 4 pairs.

  Genomic Composition: The genome of Drosophila melanogaster, 
  one of the most studied species in this family, contains approximately 13,600 protein-coding genes, 
  providing a comprehensive genetic blueprint for its development and physiology.


- `Project-Goal`: 

- reproduction of the `expression vector space analyses` results 
  as done in the `_Cardamine hirsuta_ genome project`. 
  -> for the 8 Brassicaceaen genomes
- isolate required R-Code for this purpose
- make the R-Code usable with _any_ data.
- use the R-Code to analyse public open access data of model species


- `expression vector space analyses`
- This process measures and compares gene expression levels under different conditions, 
  such as across tissues, developmental stages, or environmental contexts. 
  Differential expression analysis provides insights into the genetic mechanisms 
  underlying leaf shape and structure, identifying key genes involved in leaf development.
  Investigate how differences in gene expression correlate with functional diversification, 
  considering factors like gene group, gene family, orthologs, paralogs, or tandem duplicates.

->  High expression indicates active genes producing a lot of RNA, 

->  while low expression indicates inactive or repressed genes producing little to no RNA.

- Measure differences in gene expression profiles within gene groups by computing Euclidean distances 
  between entire gene expression profiles and along each dimension, such as tissue type.

->  Small Euclidean distances suggest similar gene expression levels between samples, 
    indicating similar gene activity.

->  Large Euclidean distances indicate differing gene expression levels between samples, 
    highlighting differences in gene activity.

- Assessing Gene Expression Changes: 
  Evaluate gene expression changes by measuring distances between mean expression vectors, 
  providing a quantitative assessment of how gene expression varies.


The steps and data required to carry out the original analysis are devided into 4 Sections 

- `1. Load tissue specific expression data`                                     (Section-1) 
- `2. Compute pairwise gene expression profile distances within gene groups`    (Section-2) 
- `3. Expression Profile based Function Diversity`                              (Section-3) 
- `4. Expression vector space analysis`                                         (Section-3)



-----------------------------------------------------------------------------------------
## Genome Assembly and Annotation
-----------------------------------------------------------------------------------------


- The genome assembly and annotation processes were completed beforehand, 
  providing a foundation for further analysis.

- Shotgun Sequencing Strategy: 
  DNA is randomly fragmented, and these fragments are cloned or 
  amplified via PCR to produce numerous short reads.

- Modern Sequencing Technologies: 
  These technologies generate millions of short DNA sequences (reads) from the genome, 
  facilitating comprehensive sequencing.

- Contig Assembly: Short reads are assembled into contigs using tools like SOAPdenovo, 
  aligning and merging overlapping reads to form longer, continuous DNA sequences.

- Superscaffold Construction: Contigs are linked into superscaffolds 
  using a Bayesian framework-based algorithm called BAMLINK, 
  creating larger, more complete genome segments.

- Anchoring Superscaffolds: Superscaffolds are anchored and oriented using 8,249 bacterial 
  artificial chromosomes (BAC), ensuring accurate genome assembly.

- Genome Annotation: This involves identifying and labeling genes within the genome sequence, 
  including gene prediction, functional annotation, and structural annotation.


-----------------------------------------------------------------------------------------
# Overview of Project Files and Rscripts
-----------------------------------------------------------------------------------------

- Section-0:    `GeneGroups`

- Section-1: `1. Load tissue specific expression data`  
- Section-2: `2. Compute pairwise gene expression profile distances within gene groups`
- Section-3: `3. Expression Profile based Function Diversity`
- Section-4: `4. Expression vector space analysis`

-----------------------------------------------------------------------------------------
## Rscripts: 
-----------------------------------------------------------------------------------------

- 1.  `loadRpkmRnaSeqCounts.R`			                                      (Section-1)
- 2.  `loadcodingSequences.R`			                                        (Section-1)

- 1.  `LoadOrthologsAndTandems.R`			                                    (Section-2)
- 2.  `defineGeneSets.R`				                                          (Section-2)
- 3.  `loadGeneFamilies.R`				                                        (Section-2)
- 4.  `computeExpressionProfileDistances.R` 	                            (Section-2)

- 1.  `investigateDistributionsOfExpressionProfileDistances.R`		        (Section-3)                          
- 2.  `plotDistributionsOfExpressionProfileDistances.R`				            (Section-3)

      `expressionProfilesDists()`         (expression_funks.R)	          (Section-3) 

- 1.  `generateRpkmExpressionProfiles.R` 		                              (Section-4) 
- 2.  `expressionAngles.R`	                                              (Section-4) 

      `exprVecSpaceEvolutionAfterDupl()` 	(expression_funks.R)            (Section-4) 
      `cosDiag()`						  	          (expression_funks.R)            (Section-4) 

-----------------------------------------------------------------------------------------
## Files:
-----------------------------------------------------------------------------------------

  Section-1:

- `RPKM_counts_table.tsv`             
- `RNA_Seq_RPKM_and_profiles.tsv`     
- `aet.fa aly.fa ath.fa bra.fa chi.fa cru.fa esa.fa tpa.fa` 
- `all.cds`

--> `RNA_Seq_RPKM_and_profiles.RData`
--> `codingSequences.RData`

-----------------------------------------------------------------------------------------

  Section-2:

- `eight_brassicaceae_tandems.txt`, `eight_brassicaceae_orthologs.txt`                      X
- `orthologs` & `tandems` 										                
- `orthologs.lst` & `tandems.lst` 								             

- `mcl_output.txt` , `mcl_table.tsv`    
- `families.lst` & `families.genes.df, families.df` 					

- `families.exp.prof.dists` & `families.exp.prof.dists.tissue`			  
- `orthologs.exp.prof.dists` & `orthologs.exp.prof.dists.tissue`			
- `tandems.exp.prof.dists` & `tandems.exp.prof.dists.tissue`

--> `orthologsTandems.RData` 
--> `GeneGroups.RData` 				 
--> `families.RData`       
--> `ExpressionProfileDistances.RData`

-----------------------------------------------------------------------------------------

  Section-3:

- `families.exp.prof.dists` 			    
- `families.exp.prof.dists.tissue`		
- `orthologs.exp.prof.dists` 			    
- `orthologs.exp.prof.dists.tissue`		
- `tandems.exp.prof.dists` 				    
- `tandems.exp.prof.dists.tissue`		 

- `tandems.exp.prof.dists.orth.dist`   
- `tandems.exp.prof.dists.orth.dist.df` 	    
- `families.exp.prof.dists.orth.dist`
- `families.exp.prof.dists.orth.dist.df` 	 
- `orthologs.exp.prof.dists.stats`
- `orthologs.exp.prof.dists.stats.df`		

--> `ExpressionProfileDistances.RData` 	
--> `ExpressionProfileDistanceDistributions.RData`
--> `families.exp.RData`    
--> `BUSTED_Results.RData`  
--> `GeneGroups.RData`

-----------------------------------------------------------------------------------------

  Section-4:

- `rpkm.rna.seq.counts` (as `RPKM_counts_table.tsv`) 
- `all.cds` 	         
- `rpkm.expr.profiles.df` 					             

- `tands.expr, orths.expr, dupl.expr, psel.expr` 	
- `tands.w.orths` 							                 
- `dupl.w.orths`							                    

- `tands.w.orths.angles.df`					             
- `tands.psel.w.orths.angles.df`				         
- `dupl.w.orths.angles.df` 					              
- `dupl.psel.w.orths.angles.df`	

--> `rpkmExpressionProfiles.RData` 
--> `GeneGroups.RData`


-----------------------------------------------------------------------------------------
## Plots:
-----------------------------------------------------------------------------------------

      Section-3:
- 1. `expressionAngleToDiagonalBoxplot.pdf`					        
- 2. `relativeExpressionVersatilityBoxplot.pdf`	
- 3. `medianExpressionProfileDistancesPerGeneGroupClassesBoxplot.pdf`
- 4. `medianExpressionProfileDistancesPerGeneGroupClassesBoxplot_NoPosSel.pdf`
- 5. `medianExpressionProfileDistancesPerGeneGroupClassesAndOrthologDistinctionBoxplot.pdf`
- 6. `medianExpressionProfileDistancesPerGeneGroupClassesAndOrthologDistinctionBoxplot_NoPosSel.pdf`
- 7. `medianExpressionDistsTandemNonOrthsAndExpandedNonOrthsHist.pdf`

      Section-4:
- 1. `meanTissueVersatilityDiffsAfterDuplicationBoxplot.pdf`	 
- 2. `meanTissueVersatilityDiffsAfterDuplicationHistograms.pdf`		
- 3. `afterDuplicationAngleBetweenOrth2DiagVecsBoxplot.pdf`			  
- 4. `afterDuplicationAngleBetweenOrth2DiagVecsHistograms.pdf`		
- 5. `meanChangeInAngleBetweenOrthOnDiagsBoxplot.pdf`			



-----------------------------------------------------------------------------------------
# `Section-GeneSets`
-----------------------------------------------------------------------------------------

- required RScripts used to generate the Input files needed for the `Section-GeneSets` 
  and to create the Genesets 

- FUBAR, BUSTED, CAFE

- exec/`loadFubarResults.R`
- exec/`loadBustedResults.R`
- exec/`parseCafeResult.R`


## Overview of Tools used for FUBAR, BUSTED, CAFE (from Command line)
-----------------------------------------------------------------------------------------

- `Hyphy` (http://www.hyphy.org/), `Hypothesis Testing using Phylogenies`

- An open-source software package for comparative sequence analysis
  using stochastic evolutionary models

- Hyphy is a command-line tool that can be used to run a variety of phylogenetic analyses.

- or Visit `Datamonkey`'s BUSTED & FUBAR Web Server. https://www.datamonkey.org/busted
- Upload the alignment file and the tree file and run the Analysis of your choice.

- HyPhy can be used for FUBAR and BUSTED Analysis 

- BUSTED Analysis in HyPhy (from Command Line) 

> hyphy busted --alignment <path-to-alignment-file> --tree <path-to-tree-file>
> hyphy busted --alignment <path-to-alignment-file> --tree <path-to-tree-file> --foreground <branch-name>
> hyphy busted --alignment alignment.fasta --tree tree.nwk

- FUBAR Analysis in HyPhy (from Command Line) 

> hyphy fubar --alignment <path-to-alignment-file> --tree <path-to-tree-file>
> hyphy fubar --alignment alignment.fasta --tree tree.nwk

> <path-to-alignment-file>: The location of your sequence alignment file.
> <path-to-tree-file>: The location of your phylogenetic tree file (usually in Newick format).

-----------------------------------------------------------------------------------------

- `CAFE5` is a command-line tool that can be used to run a variety of phylogenetic analyses.

> ./cafe5 <path-to-gene-family-data-file> <path-to-phylogenetic-tree-file>
> ./cafe5 gene_family_data.txt phylogenetic_tree.nwk
> ./cafe5 -p 0.05 -l output.log gene_family_data.txt phylogenetic_tree.nwk

- CAFE5 has several command-line options for controlling the analysis:

-p: Defines the p-value cutoff to identify significant expansions or contractions. The default is 0.01.
-l: Specifies the file for the log of results.
-s: Specifies the starting lambda value for the birth-death process.
-t: Allows testing for multiple lambdas across different branches of the tree.
-r: Runs the analysis with random birth-death rates for sensitivity testing.

-----------------------------------------------------------------------------------------

- `Translatorx` is a tool designed for aligning nucleotide sequences 
  using their corresponding protein translations. 
- use TranslatorX to generate a codon-based alignment.
- TranslatorX can be used both as an online tool and a command-line tool.
- You need nucleotide sequences (CDS) in FASTA format. 
- These sequences should represent coding regions from various species or samples.
- Ensure the sequences are CDS (coding sequences) and don’t contain introns or non-coding regions.

> translatorx_vLocal.pl -i input_sequences.fasta -o output_directory -p M -t T

-i: Input file containing the nucleotide sequences (in FASTA format).
-o: Output directory where the aligned sequences will be saved.
-p: Protein alignment algorithm. Options: - M: MUSCLE / F: MAFFT / C: ClustalW

- After running this command, the aligned sequences will be placed in output_dir as a codon-based nucleotide alignment.
- The output will include the aligned sequences in both protein and nucleotide forms.

-----------------------------------------------------------------------------------------

- `transeq`
- convert nucleotide CDS sequences into protein sequences, 

> transeq input_cds.fasta output_protein.fasta
> transeq -sequence aligned_cds.fa -outseq protein_seq.fa

-----------------------------------------------------------------------------------------

- `MAFFT` You need to align your Drosophila sequences using a tool like MAFFT, MUSCLE, or Clustal Omega. 

--> Alignment-file

> mafft --retree 1 --maxiterate 0 --auto path/2/output_all_cds.fasta > path/2/aligned_sequences.fasta
> mafft --auto path/2/file.fasta > /mnt/c/Users/andre/Desktop/aligned_sequences1.fasta
> mafft --6merpair --thread -1path/2/output_all_cds_fixed.fasta > /mnt/c/Users/a
> mafft --retree 1 --maxiterate 0 --parttree path/2/output_all_cds_fixed.fasta > path/2/aligned_sequences.fasta

--retree 1: Reduces the number of times the guide tree is built (lower computational burden).
--maxiterate 0: No iterative refinement, which saves memory.
--parttree: This mode is specifically designed for aligning large datasets more efficiently by creating a rough alignment.

-----------------------------------------------------------------------------------------

- `MUSCLE` Protein Sequence Alignment

> muscle -in output_protein.fasta -out aligned_proteins.fasta   

-----------------------------------------------------------------------------------------   

- `PAL2NAL` is a tool for translating nucleotide sequences into amino acid sequences.
- Use PAL2NAL to convert the protein alignment back to a codon-based alignment, 

> pal2nal.pl aligned_proteins.fasta aligned_cds.fa -output fasta > aligned_cds_codon.fasta
> ./pal2nal.pl path/2/protein_alignment.aln path/2/Output.aaseqs.fasta -output fasta

--------------------------------------------------------------------------------------

- `FastTree` Tree Construction Tools
- requires a multiple sequence alignment (MSA) as input. 
- sequence data from multiple Drosophila species (CDS) to create the phylogenetic tree. 
- Depending on the data you're working with, this could be either protein or nucleotide sequences 
- Ensure all your sequences are in FASTA format.
- Once you have the aligned sequences, you can build a phylogenetic tree using FastTree.

> FastTree -lg /mnt/c/Users/andre/Desktop/aligned_sequences.fasta > /mnt/c/Users/andre/Desktop/drosophila_tree.nwk
> FastTree -lg aligned_sequences.fasta > drosophila_tree.nwk

-gtr: Specifies the use of the General Time Reversible (GTR) model of nucleotide evolution.
-nt: Indicates that the input is nucleotide data.

- drosophila_tree.nwk: The output file, containing the phylogenetic tree in Newick format.

------------------------------------------------------------------------

- `paml` -> codeml
- Detect pairwise Ka/Ks ratios within closest homologs --> program `codeml`
- Based on this alignment the program `codeml` is used to compute pairwise Ka, Ks, and omega ('w') values. 
- Identification of closest homologs is done using the all-vs-all sequence similarity search results.


## Input-Files used for FUBAR, BUSTED, CAFE Analysis
--------------------------------------------------------------------------------------

- 1. `Alignment file` (sequence alignment of Nucleotid coding sequences) (MSA)

- Obtain coding sequences (CDS) from various species or samples in FASTA format, 
ensuring each sequence represents a coding region.

- Alignment File Format: Sequences must be in FASTA or NEXUS format, 
containing coding sequences (CDS) aligned by codons.

- Codon Alignment: Ensure that codons (sets of three nucleotides) are properly 
aligned across species to maintain the reading frame.

- Gaps and Reading Frame: Gaps in the alignment must respect the reading frame, 
meaning they should be in multiples of three nucleotides to avoid disrupting codon structure.

- Stop Codons: Ensure that CDS sequences do not contain stop codons, 
as tools like BUSTED analyze only coding regions.

- Convert CDS to Protein Sequences: Use tools like EMBOSS `Transeq` to 
convert nucleotide CDS sequences into protein sequences, 
ensuring no internal stop codons and correct codon alignment.

- Protein Sequence Alignment: Align the protein sequences using tools 
like `MUSCLE` or `MAFFT` to ensure accurate alignment.

- Back-Translation to Codon Alignment: Use `PAL2NAL` to convert the 
protein alignment back to a codon-based alignment, 
producing a final aligned CDS file that respects codon boundaries.

Codon-Based Alignment Tools: Tools like `MACSE` can also be used for codon-based alignments, 
ensuring the final result is a codon-aligned FASTA file suitable for further analysis.
	
--------------------------------------------------------------------------------------
	
- 2. `Phylogenetic tree file` (describing evolutionary relationships between sequences)

- Evolutionary Relationships: The phylogenetic tree represents the evolutionary 
relationships between the sequences in the alignment, illustrating connections 
among species, genes, or gene families.

- Gene Families Evolution: The tree shows how gene families, which are groups of 
related genes evolved from a common ancestor, have evolved over time, sharing similar sequences and functions.

- Branches and Gene Family Dynamics: Branches represent the expansion or contraction of gene families, 
indicating groups of genes or gene families that have increased or decreased in number over time.

- Nodes and Common Ancestors: Nodes are points where branches split, 
representing common ancestors of the gene families or species.

- Functional Diversity and Leaf Development: Expanded gene families may enhance 
functional diversity or provide more precise control over leaf development, 
leading to variations in leaf shape and structure from genotype to phenotype.

--------------------------------------------------------------------------------------

- Phylogenetic Tree Requirement: Obtain a phylogenetic tree in Newick format that 
represents the evolutionary relationships between the 12 Drosophila species.

- Tree Format and Taxa Matching: Ensure the tree is in Newick format and that the 
species names in the tree exactly match the sequence names in the alignment file to avoid analysis failure.

- Inclusion of All Taxa: The tree must include all taxa from the alignment file, 
with no extra or missing species.

- Branch Lengths: Ensure the tree includes branch lengths representing evolutionary distances, 
which are crucial for modeling substitution rates and detecting selection.

- Tree Construction Tools: Use tools like RAxML, `FastTree`, PhyML to construct the tree, 
and consider resources like `FlyBase` and `Ensembl` for extracting necessary CDS and tree files.

- Example of a Newick tree: ((speciesA:0.3,speciesB:0.3):0.2,(speciesC:0.4,speciesD:0.4):0.2);


## Fubar - Results
-----------------------------------------------------------------------------------------

- `FUBAR - Fast, Unconstrained Bayesian AppRoximation`

- is a site-level selection analysis tool used to identify evolutionary pressures 
  (positive or negative selection) on individual sites (codons) within a protein-coding sequence alignment.
- identify Gene-Families that show strong evidence of positive selection.

- BayesFactor: The key value used to determine the evidence for positive selection.
- Bayes Factor > 100 is considered decisive evidence in Bayesian statistics.

- ω (dN/dS), which is the ratio of nonsynonymous (dN) to synonymous (dS) substitution rates.
- dN: The rate of non-synonymous substitutions.
- dS: The rate of synonymous substitutions.

- ω < 1: Indicates purifying (negative) selection, where nonsynonymous mutations are deleterious.
- ω = 1: Suggests neutral evolution, where nonsynonymous mutations are neither favored nor disfavored.
- ω > 1: Indicates positive selection, where nonsynonymous mutations are being favored by evolution.

- pval: P-value for the test. Significance of the selection.
- qval: q-value for multiple testing correction. Corrected p-value.

-----------------------------------------------------------------------------------------

- RScripts used to generate the Fubar-Results needed for the `Section-GeneSets`

- exec/`generateFubarBatchFiles.R`          --> FUBAR input batch files 

- Hyphy Fubar Tool (from Command Line)	    --> FUBAR result files

--------------------------------------------------------------------------------------

- 1. Alignment file 
- 2. Phylogenetic tree file


- exec/`loadFubarResults.R`             ===> `fubar.fams.decisive.evidence` (List, Vector of Clusters)

- to process and analyze FUBAR results for gene families.
- Its main purpose is to load FUBAR result files, combine them into a single table, 
--> and identify gene families that show strong evidence of positive selection.
- It does this by filtering the table for rows where the Bayes Factor is greater than 100, 
which is considered decisive evidence in Bayesian statistics.

- Outputs: fubar.tbl (combined table of FUBAR results) + fubar.fams.decisive.evidence 

  fubar.fams.decisive.evidence (Vector of Clusters) (list)                                  X

  #  c("cluster_10", "cluster_1000", "cluster_10006", "cluster_10009", 
  #  "cluster_10021", "cluster_10024", "cluster_10025", "cluster_10036", 
  #  "cluster_10040", "cluster_10042", "cluster_10048", "cluster_10059", 
  #  "cluster_1006", "cluster_10065", "cluster_10067", "cluster_10071",)

-> (A list of gene families with decisive evidence for positive selection)


## Busted - Results
-----------------------------------------------------------------------------------------

- BUSTED Overview: BUSTED (Branch-Site Unrestricted Statistical Test for Episodic Diversification) 
  tests for episodic positive selection on specific codons across particular branches 
  of a phylogeny using a branch-site model.

- ω Values: The ratio of nonsynonymous to synonymous substitutions (dN/dS or ω) is used to indicate selection:

  ω < 1: Purifying selection.
  ω = 1: Neutral evolution.
  ω > 1: Positive selection.

- Episodic Positive Selection: BUSTED detects episodes of positive selection on some 
  branches in the phylogeny, suggesting bursts of selection at specific codons 
  while other codons or branches remain unaffected.

- Likelihood Ratio Test (LRT): BUSTED compares a null model (no positive selection) 
  to an alternative model (episodic positive selection) using a likelihood ratio test to compute a p-value.

- p-Values: A significant p-value (p < 0.05) 
  suggests evidence of episodic positive selection somewhere in the phylogeny. 
  p ≥ 0.05 indicates no significant evidence of positive selection.

- Branch-Specific Analysis: BUSTED does not identify specific branches under selection by default. 
  For detailed branch-level analysis, use aBSREL (adaptive Branch-Site REL).

- Target Branches: BUSTED can be run with specific target branches to test 
  for selection on particular parts of the phylogeny.

- Result Files: Output includes lists of genes with their Ka/Ks ratios 
  and corresponding p-values, indicating the statistical significance of 
  positive selection in each gene family.

- Alignment Requirements: Input alignments must be codon-based (in FASTA or NEXUS format) 
  and consist of nucleotide (DNA) sequences representing coding regions.

- Branch-Site Variation: BUSTED allows for variation in selection pressure across the tree, 
  testing for positive selection on the entire phylogeny or on specific branches.

-----------------------------------------------------------------------------------------


- 1. 	exec/`computePairwiseKaKsRatios.R`	(requirres: programm `codeml`)
	
- Detect pairwise Ka/Ks ratios within closest homologs --> program `codeml`
- Based on this alignment the program `codeml` is used to compute 
  pairwise Ka, Ks, and omega ('w') values.  ===> 	"pairwise.Ka.Ks"
- Identification of closest homologs is done using the all-vs-all sequence similarity search results.

- 2.  exec/`computeOrthologsKaKsRatios.R`

- 3. 	exec/`generateBustedBatchFiles.R`  (requirred: HyPhy's BUSTED)


--------------------------------------------------------------------------------------

- Inputs: Alignment file + Phylogenetic tree file

- 4. exec/`loadBustedResults.R`			

- Inputs: The script takes as input a directory path containing BUSTED result files 
  and a list of genes with a Ka/Ks ratio greater than 1 (indicating potential positive selection).

- Loop Through Gene Families: It iterates through each gene family in the BUSTED results.

- Gene Identification: For each gene family, it identifies which genes are present 
  in the provided 'all.KaKs' list (genes with Ka/Ks > 1).

- Data Assignment: The script assigns the corresponding p-value and gene family 
  name to these identified genes, storing this information in the 'busted.df' data frame.
  Output: The script generates a data frame 'busted.df' that contains information about
  the genes with evidence of positive selection. It has columns for family, gene, and p-value.

> head(`busted.df`)                                                                                       X

  #          family        gene      p.value
            
  #  1 cluster_2719      917291   0.02278408
  #  2 cluster_2719      895249   0.02278408
  #  3 cluster_2720   Bra017784   0.14893116
  #  4 cluster_2724 AT3G28870.1   0.13822553
  #  5 cluster_2729      350938   0.00000000
  #  6 cluster_2729      893755   0.00000000


## Cafe (Computational Analysis of gene Family Evolution)
-----------------------------------------------------------------------------------------

- is a tool designed to analyze the evolution of gene families across multiple species. 
- CAFE algorithm: It uses a stochastic birth-death model to analyze gene family evolution, 
  identifying expansions and contractions across species.
- Ultrametric species tree: CAFE requires an ultrametric tree, 
  where branch lengths represent evolutionary time, to track changes in gene families over time.
- Gene family changes: The tool identifies gene families that have undergone significant 
  expansion or contraction due to evolutionary pressures.
- Species-specific p-values: CAFE computes p-values for each species to determine 
  if gene family changes are statistically significant.
- Evolutionary insights: It provides insights into gene family dynamics and 
  how different evolutionary events impact family sizes across species.

- The branch lengths in the phylogenetic tree represent evolutionary distances between species. 
  These values are usually proportional to time (in millions of years) or the number of substitutions per site.

- CAFE (Computational Analysis of gene Family Evolution) is a tool designed to analyze 
  the evolution of gene families across multiple species. It uses a stochastic 
  birth-death model to study gene family expansion and contraction, allowing you to 
  infer how gene families evolve over time and identify which families 
  may be experiencing significant changes in size due to evolutionary pressures.

-----------------------------------------------------------------------------------------

- Rscript: exec/`parseCafeResult.R`


- CAFE5 uses these three main input files:

- Gene Family Data File: Lists the counts of gene family members across different species, 
  with each row representing a gene family and each column representing a species.

- Phylogenetic Tree File: Describes the evolutionary relationships between species in Newick format, 
  ensuring taxa names match those in the gene family data file.

- Branch Lengths or Divergence Times: Indicates evolutionary distances between species 
  in the phylogenetic tree, providing context for the tree's branch lengths.

- This R script is designed to parse and process results from a CAFE analysis. 
- CAFE is a tool used in bioinformatics to study the evolution of gene families across different species.
- The main purpose of this code is to extract species-specific p-values from the CAFE results, 
- The script then reads the CAFE result file and extracts information about 
  how species are mapped to nodes in the evolutionary tree.
- The main data transformation happening here is the extraction and adjustment 
  of species-specific p-values from the raw CAFE output


- input: cafe_result.txt.cafe


- main Output:
-----------------------------------------------------------------------------------------

- Gene Family Size Changes: The output table (cafe.result.df) shows gene family 
  size changes across the phylogeny, with each row representing a gene family 
  and each column (prefixed with "CAFE") representing different species.

- Statistical Significance (p-Values): CAFE5 provides p-values to indicate the significance 
  of gene family size changes for each species. Lower p-values (below the threshold, e.g., 0.01) 
  suggest more significant expansions or contractions, helping identify 
  which gene families have undergone significant evolutionary changes.

- Evolutionary Insights: Identifies which gene families have expanded or contracted 
  and specifies on which branches of the phylogenetic tree these changes occurred, 
  offering a detailed view of gene family evolution across species.

- Likelihood Scores: Outputs likelihood scores for the birth-death process, 
  aiding in understanding the dynamics of gene family evolution.

- Lambda (λ) Estimation: Estimates the birth-death rate (λ) for gene family evolution, 
  either for the entire tree or specified branches, providing insights into 
  the rate of expansion and contraction over evolutionary time.

- Comprehensive Results: The CAFE5 output includes detailed information such 
  as gene family size changes, likelihood scores, significant expansions/contractions 
  controlled by options like the p-value cutoff (-p) and the log file (-l), 
  ensuring a robust analysis of gene family evolution.


- main Output: r$> str(cafe.result.df)                                                      X

  # 'data.frame':   15162 obs. of  8 variables:

  #  $ CAFE.B.rapa       : num  0 0.048659 0 0.000525 1 ...
  #  $ CAFE.S.parvula    : num  0.000935 0 0.000483 1 1 ...
  #  $ CAFE.E.salsugineum: num  1 1 0.6904 0.0827 1 ...
  #  $ CAFE.C.hirsuta    : num  1 0 0 1 0.000554 ...
  #  $ CAFE.C.rubella    : num  1 1 1 1 1 ...
  #  $ CAFE.A.thaliana   : num  1 1 1 1 0.0374 ...
  #  $ CAFE.A.lyrata     : num  1 0 1 1 0.00183 ...
  #  $ CAFE.A.arabicum   : num  1 0 1 1 0.584 ...


## GeneSets
-----------------------------------------------------------------------------------------

  - Fubar-, Busted-, Cafe Results are used to create the following GeneSets:

  - exec/`defineGeneSets.R`

  `GeneSet 1` :   sets of genes and gene families showing signs of positive selection:
  `GeneSet 2` : 	genes and gene families showing species specific sign of
                  significant expansion or contraction:
  `GeneSet 3` : 	Conserved families are those that have an identical number of genes 
                  within each species
  `GeneSet 4` : 	Generate data containers required for the computation of annotation based
                  function diversity (Shannon-Entropies).
  `GeneSet 5` : 	Define Duplicated Gene Sets with Orthologs:
  `GeneSet 6` : 	Define lists that can be used to classify above groups into subgroups:
  `GeneSet 7` :   Define sets of expressed genes:


## Plots created by exec/`defineGeneSets.R`
-----------------------------------------------------------------------------------------
                      
  - 1. `GeneGroupsVenn.pdf`
  - 2. `ExpressedGeneGroupsVenn.pdf`

- `Venn Diagram` 

- This visualization illustrates gene families present across various species, 
  highlighting both shared and unique families. The central area shows gene families 
  common to all species, indicating conserved genes, while the outer segments represent 
  species-specific families. In the Brassicaceae family, 12,654 gene families are shared 
  among eight species, demonstrating conservation within the group. Unique gene families 
  are also noted, with C. hirsuta having 694, A. thaliana 1,020, and C. rubella 541. 
  This analysis helps explore evolutionary relationships and functional differences among these species.



-----------------------------------------------------------------------------------------
# `Section - 1: Load tissue specific expression data`
-----------------------------------------------------------------------------------------

- `Normalization of the Expression` (Transcriptome) data 

- Normalization Purpose: Adjusts for technical variations (e.g., sequencing depth, RNA quality) 
to ensure fair comparison of gene expression levels across different samples.

- Normalization Methods: Common methods include TPM (Transcripts Per Million), 
FPKM (Fragments Per Kilobase of transcript per Million mapped reads), 
and RPKM (Reads Per Kilobase of transcript per Million mapped reads).

- RPKM Overview: RPKM is used in RNA sequencing to normalize gene expression by accounting 
for both gene length and total read depth, enabling comparison between different samples.

- Gene Length Normalization: RPKM divides read counts by the gene length (in kilobases), 
preventing longer genes from appearing more highly expressed simply due to their length.

- Read Depth Adjustment: To account for variations in total read counts between samples, 
RPKM scales read counts to a million mapped reads, 
ensuring fair comparison of gene expression levels across samples.


- `RNA Sequencing for Gene Expressions`

- RNA-Seq for Gene Expression: RNA sequencing (RNA-Seq) measures gene expression 
by sequencing the complete set of RNA transcripts (the transcriptome) in a sample, 
allowing comparison of expression levels across different conditions.

. Process: RNA is converted to complementary DNA (cDNA) through reverse transcription 
and then sequenced using high-throughput technologies. 
The resulting sequences are mapped to a reference genome.

. Gene Expression Counts: The number of reads mapped to each gene indicates 
its expression level, reflecting how often the gene was transcribed in the sample.


## Step-1: `loadRpkmRnaSeqCounts.R` (1)
-----------------------------------------------------------------------------------------

- Use expresion data to generate expression profiles for different sets of genes and enable 
  comparison of them, also on the level of the tissue.

- Input: load > str(`RPKM_counts_table.tsv`) file as Input into a DataFrame.

> str(`rpkm.rna.seq.counts`)

  # 'data.frame':   1977070 obs. of  5 variables:
  # $ id        : chr  "dmel-FBgn0000003" "dmel-FBgn0000008" "dmel-FBgn0000014" "dmel-FBgn0000015" ...
  # $ tissue    : chr  "mE_mRNA_A_MateF_1d_head" "mE_mRNA_A_MateF_1d_head" "mE_mRNA_A_MateF_1d_head" "mE_mRNA_A_MateF_1d_head" ...
  # $ rank      : chr  "NA" "NA" "NA" "NA" ...
  # $ expression: num  0 10 0 0 8 1 0 58 22 2 ...
  # $ variance  : num  NA NA NA NA NA NA NA NA NA NA ...
  
- Dataset Structure: Each row represents a gene's expression vector across different plant tissues, 
  with axes for tissue types (cotyledon, developing leaf, seedling, flower stage 16, flower stage 9)            X
  and columns for gene ID and expression levels.

- Expression Measurement: Expression levels reflect gene activity, 
  indicating how much of the gene’s DNA is transcribed into RNA, varying by tissue.

- Gene Activity: Expression counts show whether genes are 
  active (ON), inactive (OFF), or repressed in each tissue.


- Output: > str(`RNA_Seq_RPKM_and_profiles.tsv`) (`rna.seq.exp.profils`)

# 'data.frame':   17681 obs. of  113 variables:

# $ mE_mRNA_A_MateF_1d_head        : num  0 0.00979 0 0 0.00701 ...
# $ mE_mRNA_A_MateF_4d_ovary       : num  0 0.0196 0 0 0.0158 ...
# $ mE_mRNA_A_MateM_1d_head        : num  0 0.0137 0 0 0.0114 ...
# $ mE_mRNA_A_VirF_1d_head         : num  0 0.01077 0 0 0.00701 ...
# $ mE_mRNA_A_VirF_4d_head         : num  0 0.00686 0 0 0.00788 ...
# $ mE_mRNA_A_MateF_20d_head       : num  0 0.00686 0 0 0.00525 ...
# $ mE_mRNA_A_MateF_4d_head        : num  0 0.00979 0 0 0.00613 ...
...
- 113 different tissues

- DataFrame Overview: The rna.seq.exp.profiles DataFrame contains 56,874 observations across 6 variables,     X
  representing gene expression values for Cardamine hirsuta in various tissues and conditions.

- Purpose: The dataset provides expression profiles for each gene, reflecting gene activity 
  based on tissue-specific expression values, with the first step being to create these profiles.


## Step-2: `loadCodingSequences.R` (2)
-----------------------------------------------------------------------------------------

  - loads the 12 DNA-Fasta-Files, for 12 Drosophila genomes, stores them into Objects/Variables
  - These files represent the genomic sequences of each species in Fasta format.
  - generates `all.cds` for the the combined 8 Brassicaceaen genomes

  - Input:  `dana.cds, dere.cds, dgri.cds, dmel.cds, dmoj.cds, dper.cds,` 
            `dpse.cds, dsec.cds, dsim.cds, dvir.cds, dwil.cds, dyak.cds`  (DNA-Fasta-Files)

  - Output: `all.cds`

  --> `codingSequences.RData`


-----------------------------------------------------------------------------------------
# `2. Compute pairwise gene expression profile distances within gene groups`
-----------------------------------------------------------------------------------------

- we want to identify Differences in expression between the 12 Drosophila Genomes
- the differences in expression are correlated with function diversification. (Funktion)
- Differences in expression are correlated with function diversification. 
  In order to detect such diversification of function we measure euclidean distances between expression 
  profiles of genes within gene groups. Distances are computed between whole 
  expression profiles as well as on each euclidean dimension (tissue).


## Tools used in Section 2:
-----------------------------------------------------------------------------------------

## Blast --> blastn (Nucleotide)
-----------------------------------------------------------------------------------

- blastn (a tool from the BLAST suite for nucleotide sequence alignment) from the command line or shell
- sudo apt-get install ncbi-blast+		(On Linux)

- BLAST (Basic Local Alignment Search Tool):
- Performs local alignment by identifying matching segments between a query sequence and sequences in a database.
- Scores alignments based on sequence similarity and calculates statistical significance (match score).
- Used to find regions of similarity between biological sequences (DNA, RNA, or proteins).
- Used for identifying homologous sequences (orthologs, paralogs, tandems)


`Formatting a FASTA file into a BLASTable database`

- If you want to search against a local database, first create it using makeblastdb:

FASTA files need to be formatted with makeblastdb before they can be used in local 
blast search. (For custom databases, the convention should be followed)

- makeblastdb -in <input_fasta_file> -dbtype nucl -out <database_name>
- makeblastdb -in family_genes.fasta -dbtype nucl -out family_db -parse_seqids

For nucleotide fasta file:   makeblastdb -in input_db -dbtype nucl -parse_seqids
For protein fasta file:      makeblastdb -in input_db -dbtype prot -parse_seqids

`all vs all alignment search`

- You can directly use the available FASTA files (CDS) of the genes against each other. 
- with the same FASTA file as both the query and the database. 
- create a custom BLAST database. (commands within same directory as blastn exec)

> blastn -query <query_file> -db <database> -out <output_file>
> blastn -query genes.fasta -db genes.fasta -out results.txt
> blastn -query family_genes.fasta -db family_db -out all_vs_all_results.txt -outfmt 6

-query <query_file>: The file containing your nucleotide sequences (FASTA format).
-db <database>: The nucleotide database to search against. (use a pre-downloaded database or build a custom one.)
-out <output_file>: The name of the output file where results will be saved.

- evalue <value>: Set the expected value threshold (default is 10).

- blastn -query query.fasta -db nt -out output.txt -evalue 0.001

- max_target_seqs <number>: Limit the number of target sequences to show (default is 500).

- blastn -query query.fasta -db nt -out output.txt -max_target_seqs 10

- Output: all_vs_all_tabular_blast_out.txt 

## 13. Markov Clustering 
-----------------------------------------------------------------------------------

- Markov Clustering (mcl Programm (`mcl 14-137, van Dongen`)): 

Clustering Data: Grouping items based on similarities or connections, such as genes, 
into categories or clusters (e.g., orthologs or paralogs).

Similarity Matrix: A matrix showing the degree of similarity or connection between 
items (e.g., genes) based on scores from comparisons (e.g., BLAST).

Purpose: To create gene families by grouping orthologs across species and paralogs within the same species.

Identification Process:

Run all-vs-all BLAST/BLAT searches on coding sequences from multiple genomes.
Identify reciprocal best hits in the sequence similarity search.
Use Markov Clustering (MCL) to group genes based on pairwise sequence similarities.
MCL Algorithm: Implemented in the mcl program, version 14-137, and used to process similarity data into clusters.

Output Processing: Convert MCL results into a table format with cluster names 
and gene counts using the Perl script mcl2orthoformat.pl.
->  `mcl_output.txt` ---->  `mcl_table.tsv`

- results were parsed and provided as a table (Perl-Script) in which each family 
  was assigned a cluster_name  and for each of the eight species the number of gene members is provided.


## Step-1:  `LoadOrthologsAndParalogs.R` (1) 
-----------------------------------------------------------------------------------------

- load Information about the Orthologs and Tandems identified within the eight Brassicaceaen Genomes
- the txt Files contain Information about Pairwise Sequence Similarities (Orthologs & Paralogs)

  - orthologs (genes in different species with a common ancestor), They typically retain 
  the same function across species. genes from multiple species. These genes are found in the same cluster 
  because they share a high degree of sequence similarity, which suggests that they are orthologs.

- Tandem duplicates: are genes that have duplicated within the same genome, 
  often appearing next to each other on the chromosome. If a cluster includes multiple genes 
  from the same species that are very similar to each other, these may be tandem duplicates. 
  These genes are grouped together in the cluster because they have 
  very similar sequences due to recent duplication events.


- Input:  dmel.txt

- Output: orthologs + paralogs (Dataframes) -> saved in: `orthologsTandems.RData`

> dim(orthologs)
  [1] 16077    13

> summary(orthologs)

  #  Orthogroup            dana               dere               dgri
  Length:16077       Length:16077       Length:16077       Length:16077
  Class :character   Class :character   Class :character   Class :character
  Mode  :character   Mode  :character   Mode  :character   Mode  :character
  #    dmel               dmoj               dper               dpse
  Length:16077       Length:16077       Length:16077       Length:16077
  Class :character   Class :character   Class :character   Class :character
  Mode  :character   Mode  :character   Mode  :character   Mode  :character
  #    dsec               dsim               dvir               dwil
  Length:16077       Length:16077       Length:16077       Length:16077
  Class :character   Class :character   Class :character   Class :character
  Mode  :character   Mode  :character   Mode  :character   Mode  :character
  #    dyak
  Length:16077
  Class :character
  Mode  :character

r$> head(`paralogs`) (Dataframe, 223055 Objects/Elements)

  #               Family                Gene
  # 1 paralogs_cluster_0    dmel-FBgn0029830
  # 2 paralogs_cluster_0    dmel-FBgn0029835
  # 3 paralogs_cluster_0    dmel-FBgn0001263
  # 4 paralogs_cluster_0    dmel-FBgn0067864
  # 5 paralogs_cluster_0    dmel-FBgn0000163
  # 6 paralogs_cluster_0    dmel-FBgn0026313
  ...


## Step-2: `defineGeneSets.R` (2) 
-----------------------------------------------------------------------------------------

`GeneSet 4` : 	Generate data containers required for the computation of annotation based  			        
                function diversity (Shannon-Entropies).

- Inputs: `orthologs & tandems` (Dataframes)

- Outputs: orthologs.lst , tandems.lst


r$> str(orthologs.lst) List of 16077 objects (ortholog clusters)

# $ ortholog_cluster_1    : Named chr [1:13] "OG0000000" "FBgn0090932, FBgn0092744, FBgn0092910, FBgn0092945, FBgn0095994, FBgn0096182, FBgn0096292, FBgn0097172, FBgn009"| #__truncated__ "FBgn0103302, FBgn0103306, FBgn0103309, FBgn0103312, FBgn0104863, FBgn0104867, FBgn0105228, FBgn0105263, FBgn010"| __truncated__ "FBgn0117630, FBgn0117652, #FBgn0118969, FBgn0130789, FBgn0130791, FBgn0130796, FBgn0130801, FBgn0130926, FBgn013"| __truncated__ ...
#  ..- attr(*, "names")= chr [1:13] "Orthogroup" "dana" "dere" "dgri" ...
# $ ortholog_cluster_2    : Named chr [1:13] "OG0000001" "FBgn0090950, FBgn0091434, FBgn0092911, FBgn0092946, FBgn0093040, FBgn0095967, FBgn0095992, FBgn0096019, FBgn009"| #__truncated__ "FBgn0103253, FBgn0103288, FBgn0103300, FBgn0103304, FBgn0103307, FBgn0103310, FBgn0103313, FBgn0103354, FBgn010"| __truncated__ "FBgn0117663, FBgn0121413, #FBgn0129951, FBgn0130790, FBgn0130802, FBgn0130873, FBgn0130947, FBgn0130972, FBgn013"| __truncated__ ...
#  ..- attr(*, "names")= chr [1:13] "Orthogroup" "dana" "dere" "dgri" ...
# $ ortholog_cluster_3    : Named chr [1:13] "OG0000002" "FBgn0088059, FBgn0092909, FBgn0092912, FBgn0092944, FBgn0095878, FBgn0095993, FBgn0096291, FBgn0096319, FBgn009"| #__truncated__ "FBgn0103254, FBgn0103267, FBgn0103305, FBgn0103308, FBgn0103311, FBgn0103315, FBgn0104862, FBgn0104865, FBgn010"| __truncated__ "FBgn0129952, FBgn0130787, # # #FBgn0130792, FBgn0130794, FBgn0130797, FBgn0130800, FBgn0130948, FBgn0130960, FBgn013"| __truncated__ ...
#  ..- attr(*, "names")= chr [1:13] "Orthogroup" "dana" "dere" "dgri" ...

r$> str(paralogs.lst) List of 10772 objects (tandem_clusters)

# List of 10772
# $ paralogs_cluster_0    : chr [1:28] "dmel-FBgn0029830" "dmel-FBgn0029835" "dmel-FBgn0001263" "dmel-FBgn0067864" ...
# $ paralogs_cluster_1    : chr [1:82] "dmel-FBgn0030058" "dmel-FBgn0026411" "dmel-FBgn0020617" "dmel-FBgn0008636" ...
# $ paralogs_cluster_2    : chr [1:86] "dmel-FBgn0029697" "dmel-FBgn0030058" "dmel-FBgn0026411" "dmel-FBgn0020617" ...
# $ paralogs_cluster_3    : chr [1:60] "dmel-FBgn0000382" "dmel-FBgn0003079" "dmel-FBgn0003731" "dmel-FBgn0028484" ...
# $ paralogs_cluster_4    : chr [1:24] "dmel-FBgn0004170" "dmel-FBgn0002561" "dmel-FBgn0000137" "dmel-FBgn0011276" ...
# $ paralogs_cluster_5    : chr [1:33] "dmel-FBgn0029690" "dmel-FBgn0000326" "dmel-FBgn0034736" "dmel-FBgn0034972" ...
...
 


## Step-3: `loadGeneFamilies.R` (3) 
-----------------------------------------------------------------------------------------

- Clusters: In the context of gene families, a cluster refers to a group of genes that are related 
  by sequence similarity and are assumed to have evolved from a common ancestor. 
  Clusters represent groups of related genes, identified by their sequence similarity across different species

- Inputs: `mcl_output.txt` , `mcl_table.tsv` (from markov clustering tool mcl) 

- Outputs: `families.lst` & `families.genes.df, families.df` --> `families.RData`


r$> str(families.lst) List of List of 1244 objects (clusters)

 # $ cluster_1   :List of 47
 # ..$ : chr "dmel-FBgn0034997"
 # ..$ : chr "dana-FBgn0144047"
 # ..$ : chr "dvir-FBgn0088427"
 # ..$ : chr "dpse-FBgn0208706"
 # ..$ : chr "dsec-FBgn0077426"
 # ..$ : chr "dwil-FBgn0166790"
 # ..$ : chr "dper-FBgn0224185"
 # ..$ : chr "dyak-FBgn0157602"
 # ..$ : chr "dsim-FBgn0232001"
 # ..$ : chr "dere-FBgn0183587"
 # ...
 # $ cluster_2   :List of 72
 # ..$ : chr "dmel-FBgn0263598"
 # ..$ : chr "dana-FBgn0140828"
 # ..$ : chr "dvir-FBgn0091241"
 # ..$ : chr "dpse-FBgn0250311"
 # ..$ : chr "dsec-FBgn0165036"
 # ..$ : chr "dwil-FBgn0217312"
 # ..$ : chr "dper-FBgn0236016"
 # ..$ : chr "dyak-FBgn0195230"

> str(families.df)

# 'data.frame':   1244 obs. of  14 variables:
# $ id  : chr  "cluster_1" "cluster_2" "cluster_3" "cluster_4" ...
# $ dmel: num  4 6 1 3 12 15 1 5 19 4 ...
# $ dana: num  4 6 1 3 12 14 1 5 18 4 ...
# $ dvir: num  4 6 1 3 12 14 1 5 18 4 ...
# $ dpse: num  4 6 1 3 12 13 1 5 18 4 ...
# $ dsec: num  4 6 1 3 12 13 1 5 18 4 ...
# $ dwil: num  4 6 1 2 10 12 1 5 18 4 ...
# $ dper: num  4 6 1 2 10 11 1 5 18 4 ...
# $ dyak: num  4 6 1 3 12 13 1 5 18 4 ...
# $ dsim: num  4 6 1 2 12 14 1 5 18 4 ...
# $ dere: num  4 6 1 2 12 13 1 5 18 4 ...
# $ dgri: num  3 6 1 2 10 10 1 5 15 4 ...
# $ dmoj: num  4 6 1 2 10 11 1 5 16 4 ...
# $ size: num  43 66 11 28 126 142 11 55 196 44 ...



## Step-4: `computeExpressionProfileDistances.R` (4)
-----------------------------------------------------------------------------------------

Euclidean Distance Calculation: Within each gene cluster, Euclidean distances 
between gene expression profiles are computed pairwise to measure similarities 
or differences in gene activity levels.

R dist Function: The dist function in R calculates these pairwise distances, 
resulting in a condensed distance object that stores the distances 
between all pairs of genes in the cluster. -
--> `expressionProfilesDists` function() from expression_funks.R

Distance Object: The dist object contains pairwise distances in a compact form, 
with values representing the Euclidean distances between gene expression profiles within the cluster.

Data Representation: The distance object is a single vector where each element 
represents the distance between a unique pair of genes, stored in a condensed format.

Example Calculation: For a cluster with 161 genes, there are 12,880 pairwise distances, 
which are represented in the dist object as a vector of distances.

- Inputs (Lists of Genes): `tandems.lst`, `orthologs.lst`, `families.lst`

orthologs.lst:  Contains genes grouped into ortholog clusters.
tandems.lst:    Contains genes grouped into tandem clusters.
families.lst:   Likely contains gene families, though specific details are not provided.


- Outputs:  --> stored in `ExpressionProfileDistances.RData`

  - `families.exp.prof.dists` & `families.exp.prof.dists.tissue`
  - `orthologs.exp.prof.dists` & `orthologs.exp.prof.dists.tissue`
  - `tandems.exp.prof.dists` & `tandems.exp.prof.dists.tissue`

List Structure: The data is organized as a list of R dist objects, 
one for each gene family (e.g., cluster_1), where each dist object contains 
pairwise Euclidean distances between genes.

Nested List Details: This list is further nested, with gene families at the 
top level and individual tissues at the next level, where each tissue has its own 
dist object representing Euclidean distances between gene pairs specific to that tissue.

-----------------------------------------------------------------------------------------

  str(`families.exp.prof.dists`) List of 1244 (Key: Value pairs)

# $ cluster_1   : 'dist' num [1:6] 0.185 0.304 0.306 0.239 0.245 ...
#  ..- attr(*, "Size")= int 4
#  ..- attr(*, "Labels")= chr [1:4] "dmel-FBgn0034997" "dmel-FBgn0035421" "dmel-FBgn0039768" "dmel-FBgn0039769"
#  ..- attr(*, "Diag")= logi FALSE
#  ..- attr(*, "Upper")= logi FALSE
#  ..- attr(*, "method")= chr "euclidean"
#  ..- attr(*, "call")= language dist(x = exp.profs[, tissues], method = dist.method)
# $ cluster_2   : 'dist' num [1:3] 0.403 0.395 0.144
#  ..- attr(*, "Size")= int 3
#  ..- attr(*, "Labels")= chr [1:3] "dmel-FBgn0032464" "dmel-FBgn0263598" "dmel-FBgn0265262"
#  ..- attr(*, "Diag")= logi FALSE
#  ..- attr(*, "Upper")= logi FALSE
#  ..- attr(*, "method")= chr "euclidean"
#  ..- attr(*, "call")= language dist(x = exp.profs[, tissues], method = dist.method)

  str(`families.exp.prof.dists.tissue`) [1] 1244

#  ..$ mE_mRNA_L3_Wand_saliv          : 'dist' num [1:6] 0.000814 0.0005 0.0005 0.001315 0.001315 ...
#  .. ..- attr(*, "Size")= int 4
#  .. ..- attr(*, "Labels")= chr [1:4] "dmel-FBgn0034997" "dmel-FBgn0035421" "dmel-FBgn0039768" "dmel-FBgn0039769"
#  .. ..- attr(*, "Diag")= logi FALSE
#  .. ..- attr(*, "Upper")= logi FALSE
#  .. ..- attr(*, "method")= chr "euclidean"
#  .. ..- attr(*, "call")= language dist(x = setNames(exp.profs[, tissue], rownames(exp.profs)), method = dist.method)
#  ..$ mE_mRNA_A_VirF_20d_head        : 'dist' num [1:6] 0.00212 0.00475 0.00475 0.00263 0.00263 ...
#  .. ..- attr(*, "Diag")= logi FALSE
#  .. ..- attr(*, "Upper")= logi FALSE
#  .. ..- attr(*, "method")= chr "euclidean"
#  .. ..- attr(*, "call")= language dist(x = setNames(exp.profs[, tissue], rownames(exp.profs)), method = dist.method)
#  ..$ mE_mRNA_A_VirF_20d_head        : 'dist' num [1:6] 0.00212 0.00475 0.00475 0.00263 0.00263 ...
#  .. ..- attr(*, "method")= chr "euclidean"
#  .. ..- attr(*, "call")= language dist(x = setNames(exp.profs[, tissue], rownames(exp.profs)), method = dist.method)



> str(`orthologs.exp.prof.dists`) List of 10111




> str(`orthologs.exp.prof.dists.tissue`) List of 10111




> str(`paralogs.exp.prof.dists`) List of [1] 10772

# $ paralogs_cluster_96   : 'dist' num [1:351] 0.0578 0.0721 0.0593 0.0413 0.0722 ...
#  ..- attr(*, "Size")= int 27
#  ..- attr(*, "Labels")= chr [1:27] "dmel-FBgn0005322" "dmel-FBgn0013563" "dmel-FBgn0016983" "dmel-FBgn0020369" ...
#  ..- attr(*, "Diag")= logi FALSE
#  ..- attr(*, "Upper")= logi FALSE
#  ..- attr(*, "method")= chr "euclidean"
#  ..- attr(*, "call")= language dist(x = exp.profs[, tissues], method = dist.method)
# $ paralogs_cluster_97   : 'dist' num [1:6] 0.189 0.306 0.12 0.273 0.109 ...
#  ..- attr(*, "Size")= int 4
#  ..- attr(*, "Labels")= chr [1:4] "dmel-FBgn0001086" "dmel-FBgn0030011" "dmel-FBgn0034937" "dmel-FBgn0262699"
#  ..- attr(*, "Diag")= logi FALSE
#  ..- attr(*, "Upper")= logi FALSE
#  ..- attr(*, "method")= chr "euclidean"
#  ..- attr(*, "call")= language dist(x = exp.profs[, tissues], method = dist.method)

> str(`paralogs.exp.prof.dists.tissue`) List of [1] 10772

#  ..$ mE_mRNA_WPP_fat                : 'dist' num [1:378] 0.003125 0.001315 0.002061 0.000271 0.003383 ...
#  .. ..- attr(*, "Size")= int 28
#  .. ..- attr(*, "Labels")= chr [1:28] "dmel-FBgn0000163" "dmel-FBgn0001263" "dmel-FBgn0001624" "dmel-FBgn0010620" ...
#  .. ..- attr(*, "Diag")= logi FALSE
#  .. ..- attr(*, "Upper")= logi FALSE
#  .. ..- attr(*, "method")= chr "euclidean"
#  .. ..- attr(*, "call")= language dist(x = setNames(exp.profs[, tissue], rownames(exp.profs)), method = dist.method)
#  ..$ mE_mRNA_WPP_saliv              : 'dist' num [1:378] 0 0.00197 0.00355 0.01273 0.01374 ...
#  .. ..- attr(*, "Size")= int 28
#  .. ..- attr(*, "Labels")= chr [1:28] "dmel-FBgn0000163" "dmel-FBgn0001263" "dmel-FBgn0001624" "dmel-FBgn0010620" ...
#  .. ..- attr(*, "Diag")= logi FALSE
#  .. ..- attr(*, "Upper")= logi FALSE
#  .. ..- attr(*, "method")= chr "euclidean"
#  .. ..- attr(*, "call")= language dist(x = setNames(exp.profs[, tissue], rownames(exp.profs)), method = dist.method)
